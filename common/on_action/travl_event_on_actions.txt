# Called from code after history generation
# Empty scope
on_game_start = {
	on_actions = { travl_on_init }
}

travl_on_init = {
	trigger = {
		NOT = { has_global_variable = travl_initialized }
	}
	events = {
		travl_travel.0001
	}
	effect = {
		set_global_variable = travl_initialized
		travl_debug_log_effect = { MSG = travl_debug_msg_initialized }
	}
}

# Characters getting married
# root = Major partner of the marriage
# scope:spouse = Minor partner of the marriage
on_marriage = {
	on_actions = { travl_on_init travl_on_marriage }
}

travl_on_marriage = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_married_major }
		travl_restore_location_effect = yes
		scope:spouse = {
			travl_debug_log_event_effect = { MSG = travl_debug_msg_character_married_minor }
			travl_restore_location_effect = yes
		}
	}
}

# Characters get divorced in any way
# root = character initiating the divorce
# scope:spouse = the divorced spouse
# scope:reason = flag:script or flag:faith
on_divorce = {
	on_actions = { travl_on_divorce }
}

travl_on_divorce = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_divorced }
		travl_restore_location_effect = yes
		scope:spouse = {
			travl_debug_log_event_effect = { MSG = travl_debug_msg_character_was_divorced }
			travl_restore_location_effect = yes
		}
	}
}

# Character becomes another's concubine
# root = the concubinist
# scope:concubine = the concubine
on_concubinage = {
	on_actions = { travl_on_concubinage }
}

travl_on_concubinage = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_took_concubine }
		travl_restore_location_effect = yes
		scope:concubine = {
			travl_debug_log_event_effect = { MSG = travl_debug_msg_character_was_taken_concubine }
			travl_restore_location_effect = yes
		}
	}
}

# Character ceases to be another's concubine
# root = the concubinist
# scope:concubine = the concubine
# scope:reason = flag:death, flag:faith, or flag:script
on_concubinage_end = {
	on_actions = { travl_on_concubinage_end }
}

travl_on_concubinage_end = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_released_concubine }
		travl_restore_location_effect = yes
		scope:concubine = {
			travl_debug_log_event_effect = { MSG = travl_debug_msg_character_was_released_concubine }
			travl_restore_location_effect = yes
		}
	}
}

# Fires when a character joins a court. Not fired for just generated characters
# Root is the character
# scope:new_employer is their new employer
# scope:old_employer is their old employer (if they had one; otherwise unset)
on_join_court = {
	on_actions = { travl_on_init travl_on_join_court }
}

travl_on_join_court = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_joined_court }

		# Determine sender
		if = {
			limit = { exists = scope:old_employer }
			scope:old_employer = { save_scope_as = sender }
		}
		else = {
			this = { save_scope_as = sender }
		}

		# Determine receiver
		travl_set_receiver_effect = yes

		travl_travel_to_court_effect = {
			SENDER = scope:sender
			RECEIVER = scope:receiver
			EVENT = flag:on_join_court
		}
	}
}

# Fires when a character leaves a court. Not fired when leaving due to death or similar
# Will still fire even if on_join_court is firing (fires just before it)
# Root is the character
# scope:old_employer is their old employer
on_leave_court = {
	on_actions = { travl_on_leave_court }
}

travl_on_leave_court = {
	effect = {
		if = {
			limit = { is_pool_character = no }
			travl_debug_log_event_effect = { MSG = travl_debug_msg_character_left_court }
			travl_travel_to_location_effect = { EVENT = flag:on_leave_court }
		}
		else = {
			travl_abort_travel_effect = yes
		}
	}
}

# Code on-action: character being imprisoned in root scope
# imprisoning character set as scope:imprisoner
on_imprison = {
	on_actions = { travl_on_imprison }
}

travl_on_imprison = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_imprisoned }
		travl_travel_to_location_effect = { EVENT = flag:on_imprison }
	}
}

# Code on-action: character released from prison in root scope. Does not fire when "released" due to dying
# imprisoning character set as scope:imprisoner
on_release_from_prison = {
	on_actions = { travl_on_release_from_prison }
}

travl_on_release_from_prison = {
	effect = {
		if = {
			limit = { is_pool_character = no }

			travl_debug_log_event_effect = { MSG = travl_debug_msg_character_released_from_prison }

			# Determine sender
			if = {
				limit = { exists = scope:imprisoner }
				scope:imprisoner = { save_scope_as = sender }
			}
			else = {
				this = { save_scope_as = sender }
			}

			# Determine receiver
			travl_set_receiver_effect = yes

			travl_travel_to_court_effect = {
				SENDER = scope:sender
				RECEIVER = scope:receiver
				EVENT = flag:on_release_from_prison
			}
		}
		else = {
			travl_abort_travel_effect = yes
		}
	}
}

# A title is transferred to a new character
# root = the new holder
# scope:title = the title that changes hands
# scope:previous_holder = previous holder. Might be dead
on_title_gain = {
	on_actions = { travl_on_title_gain }
}

travl_on_title_gain = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_gained_title }
		travl_travel_to_location_effect = { EVENT = flag:on_title_gain }
	}
}

# A title is lost by a character
# root = the old holder
# scope:title = the title that changes hands
# scope:new_holder = new holder.
on_title_lost = {
	on_actions = { travl_on_title_lost }
}

travl_on_title_lost = {
	effect = {
		if = {
			limit = { is_pool_character = no }
			travl_debug_log_event_effect = { MSG = travl_debug_msg_character_lost_title }
			travl_travel_to_location_effect = { EVENT = flag:on_title_lost }
		}
		else = {
			travl_abort_travel_effect = yes
		}
	}
}

travl_on_teleport = {
	effect = {
		travl_debug_log_event_effect = { MSG = travl_debug_msg_character_teleported }
		travl_travel_to_location_effect = { EVENT = flag:on_teleport }
	}
}

# called when a siege completes. Does *not* fire on reoccupation by province order
# root is the occupant
# scope:barony is the barony title that got occupied
# scope:county is the county title for the barony
# scope:previous_controller is the previous controller of the county
# scope:war is the war causing the previous controller and the occupant to be hostile
# occupied_baronies is a list of all baronies that the siege caused the occupier to control (I.E., can include baronies with no fort level)
#on_siege_completion = {
#}

# Called when a raid action finishes
# root is the raid army
# scope:raider is the person owning the raid army
# scope:barony is the barony title that got raided
# scope:county is the county title for the barony
#on_raid_action_completion = {
#}

# Root = Winning combat side
# scope:wipe - Was this a wipe?
on_combat_end_winner = {
	on_actions = { travl_on_combat_end_winner }
}

travl_on_combat_end_winner = {
	effect = {
		combat.location = { save_scope_as = combat_location }
		every_side_knight = {
			limit = { is_alive = yes }
			set_variable = {
				name = travl_location
				value = scope:combat_location
			}
		}
		every_side_commander = {
			limit = { is_alive = yes }
			set_variable = {
				name = travl_location
				value = scope:combat_location
			}
		}
	}
}

# Root = Losing combat side
# scope:wipe - Was this a wipe?
on_combat_end_loser = {
	on_actions = { travl_on_combat_end_loser }
}

travl_on_combat_end_loser = {
	effect = {
		combat.location = { save_scope_as = combat_location }
		every_side_knight = {
			limit = { is_alive = yes }
			set_variable = {
				name = travl_location
				value = scope:combat_location
			}
		}
		every_side_commander = {
			limit = { is_alive = yes }
			set_variable = {
				name = travl_location
				value = scope:combat_location
			}
		}
	}
}

#on_war_won_attacker = {
#}

#on_war_won_defender = {
#}